public class Game {

    private long window;
    private int width = 1280;
    private int height = 720;
    private WorldManager worldManager;

    private Camera camera;
    private ShaderProgram shaderProgram;
    private ShaderProgram selectorShader;
    private Cube cubePreview;

    //Fuente
    private TextRenderer textRenderer;

    //TEXTURAAAAS
    private Texture grassT;
    private Texture dirtT;
    private Texture stoneT;

    //BLOQUES DE STEVE
    private final Block[] availableBlocks = {Block.GRASS, Block.DIRT, Block.STONE};
    private int selectedBlockIndex = 0;
    private Block selectedBlock = availableBlocks[selectedBlockIndex];

    private float mouseSensitivity = 0.1f;
    private float movementSpeed = 5f;

    private float floatingCheckTimer = 0;
    public static float gravityDelayTime = 2.0f;
    public static final float GRAVITY_COUNTDOWN_TIME = 0.25f;

    private final List<Vector3i> fallingBlocks = new ArrayList<>();

    //Click x default
    private boolean leftClickPressed = false;
    private boolean rightClickPressed = false;
    private boolean leftClickHeld = false;
    private float destroyCountDown = 0f;
    private float placeCountDown = 0f;
    private float fallCountDown = 0f;
    private final float DESTROY_COUNTDOWN_TIME = 0.25f;
    private final float PLACE_COUNTDOWN_TIME = 0.25f;
    private final float FALL_COUNTDOWN_TIME = 0.20f;

    private BlockSelector blockSelector;

    private ChunkLoaderThread chunkLoader;

    // Para movimiento del mouse
    private double lastMouseX = width / 2.0;
    private double lastMouseY = height / 2.0;
    private boolean firstMouse = true;
    private float scrollOffsetY = 0;

    private Vector3f velocity = new Vector3f(0, 0, 0);
    private final float gravity = -30;
    private final float jumpForce = 10f;
    private boolean isOnGround = false;

    public void run() throws Exception {
        init();
        loop();
        cleanup();
    }

    private void init() throws Exception {
        GLFWErrorCallback.createPrint(System.err).set();
        if (!glfwInit()) {
            throw new IllegalStateException("No se pudo inicializar GLFW");
        }
        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);
        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
        window = GLFW.glfwCreateWindow(width, height, "Minecraft Clone", NULL, NULL);
        if (window == NULL) {
            throw new RuntimeException("No se pudo crear la ventana GLFW");
        }
        glfwMakeContextCurrent(window);
        glfwSwapInterval(1);
        glfwShowWindow(window);
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        GL.createCapabilities();
        glEnable(GL_DEPTH_TEST);
        glClearColor(0.53f, 0.8f, 0.92f, 1.0f);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glViewport(0, 0, width, height);

        glfwSetScrollCallback(window, (win, xoffset, yoffset) -> {
            if (yoffset > 0) {
                selectedBlockIndex = (selectedBlockIndex + 1) % availableBlocks.length;
            } else if (yoffset < 0) {
                selectedBlockIndex = (selectedBlockIndex - 1 + availableBlocks.length) % availableBlocks.length;
            }

            selectedBlock = availableBlocks[selectedBlockIndex];
            textRenderer.updateText(selectedBlock.getType().name());
            System.out.println("Bloque seleccionado (scroll): " + selectedBlock.getType());
        });

        camera = new Camera();
        blockSelector = new BlockSelector();
        shaderProgram = new ShaderProgram("res/shaders/vertex.glsl", "res/shaders/fragment.glsl");
        selectorShader = new ShaderProgram("res/shaders/selector_vertex.glsl", "res/shaders/selector_fragment.glsl");
        grassT = new Texture("res/textures/grass_texture.png");
        dirtT = new Texture("res/textures/dirt_texture.png");
        stoneT = new Texture("res/textures/stone_texture.png");
        cubePreview = new Cube();

        // Font font = new Font("Arial", Font.BOLD, 32);
        Font font = null;
        try {
            font = Font.createFont(Font.TRUETYPE_FONT, new File("res/fonts/MinecraftRegular-Bmg3.otf")).deriveFont(32f);
            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
            ge.registerFont(font);
        } catch (Exception e) {
            e.printStackTrace();
            font = new Font("Arial", Font.BOLD, 32); // fallback
        }
        textRenderer = new TextRenderer(selectedBlock.getType().toString(), font, Color.WHITE);

        // 1) Crear el WorldManager
        worldManager = new WorldManager(camera, shaderProgram, grassT, dirtT, stoneT);

        // 2) **Crear SINCRÓNICAMENTE el chunk base (0,0,0) para que nunca caigamos al vacío**:
        Chunk baseChunk = new Chunk(0, 0, 0);

        baseChunk.generate();      // genera el terreno hasta y=4
        baseChunk.buildMesh();     // crea VAO/VBO para dibujar

        String key = baseChunk.getKey();
        worldManager.chunks.put(key, baseChunk);  // mete el chunk base en el mapa de chunks

        System.out.println("Chunk base insertado:" + worldManager.getChunks().get("0,0,0").getKey());
        System.out.println("Claves Actuales:" + worldManager.getChunks().keySet());

        //Comprobacion
        Block x = worldManager.getBlockIfLoader(8, 4, 8);
        if (x.isSolid() && x == GRASS) {
            System.out.println("Bloque justo antes de setposition es solido(8,4,8): Grass");
        } else {
            System.out.println("Bloque justo antes de setposition es solido(8,4,8): Air");
        }

        Block blockbellow = worldManager.getBlockIfLoader(8, 4, 8);
        if (blockbellow.isSolid() && blockbellow != AIR) {
            System.out.println("Bloque luego de setposition(8,4,8): Grass");
        } else {
            System.out.println("Bloque luego de setposition(8,4,8): Air");
        }

        camera.setPosition(8f, 5.1f, 8f);

        isOnGround = true;

        // 4) Ahora sí creo y arranco el hilo para cargar el resto de chunks en segundo plano
        chunkLoader = new ChunkLoaderThread(worldManager);
        worldManager.setChunkLoader(chunkLoader);

        MeshBuilderThread meshThread = new MeshBuilderThread(worldManager);
        worldManager.setMeshBuilder(meshThread);

        chunkLoader.start();

        worldManager.startThreads();

    }

    private void detectFloatingBlocksInCurrentChunk() {
        Vector3f camPos = camera.getPosition();

        int chunkX = Math.floorDiv((int) camPos.x, Chunk.SIZEx);
        int chunkY = Math.floorDiv((int) camPos.y, Chunk.SIZEy);
        int chunkZ = Math.floorDiv((int) camPos.z, Chunk.SIZEz);

        Chunk chunk = worldManager.getChunk(chunkX, chunkY, chunkZ);
        if (chunk == null) {
            return;
        }

        for (int x = 0; x < Chunk.SIZEx; x++) {
            for (int y = 0; y < Chunk.SIZEy; y++) {
                for (int z = 0; z < Chunk.SIZEz; z++) {
                    Block blockId = chunk.getBlock(x, y, z);
                    if (blockId == AIR) {
                        continue;
                    }

                    int worldX = chunkX * Chunk.SIZEx + x;
                    int worldY = chunkY * Chunk.SIZEy + y;
                    int worldZ = chunkZ * Chunk.SIZEz + z;

                    if (!worldManager.hasSupport(worldX, worldY, worldZ)) {
                        Vector3i pos = new Vector3i(worldX, worldY, worldZ);
                        if (!fallingBlocks.contains(pos)) {
                            fallingBlocks.add(pos);
                        }
                    }
                }
            }
        }
    }

    private void applyGravity(float deltaTime) {
        if (gravityDelayTime > 0) {
            gravityDelayTime -= deltaTime;
            return;
        }
        if (!isOnGround) {
            velocity.y += gravity * deltaTime;
        }

        Vector3f nextPos = new Vector3f(camera.getPosition());
        nextPos.y += velocity.y * deltaTime;

        if (collidesWithWorld(nextPos)) {
            if (velocity.y < 0) {
                isOnGround = true;
                velocity.y = 0;

                // Ajustamos para evitar flotar o atravesar el suelo
                float alignedY = (float) Math.floor(camera.getPosition().y);
                camera.setPosition(camera.getPosition().x, alignedY, camera.getPosition().z);
            }
        } else {
            camera.setPosition(camera.getPosition().x, nextPos.y, camera.getPosition().z);
            isOnGround = false;
        }

    }

    private void loop() throws Exception {
        float lastTime = (float) glfwGetTime();

        while (!glfwWindowShouldClose(window)) {
            float currentTime = (float) glfwGetTime();
            float deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            glfwPollEvents();

            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            handleMouse();
            handleKeyboard(deltaTime);
            applyGravity(deltaTime);

            RaycastResult selectedblock = RaycastUtils.raycast(worldManager, camera.getEyePosition(), camera.getFront(), 5.0f);
            if (selectedblock != null) {

                blockSelector.render(selectedblock.blockPos, camera.getProjectionMatrix(70, (float) width / height, 0.01f, 1000f),
                        camera.getViewMatrix(), selectorShader);

                System.out.println("Apuntas al bloque: " + selectedblock.blockPos + " cara: " + selectedblock.faceNormal);

                Vector3f blockPos = selectedblock.blockPos;
                Vector3f normal = selectedblock.faceNormal;

                destroyCountDown -= deltaTime;
                placeCountDown -= deltaTime;

                // Clic izquierdo = destruir bloque
                boolean isLeftPressed = GLFW.glfwGetMouseButton(window, GLFW.GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS;
                if (destroyCountDown <= 0 && isLeftPressed) {
                    worldManager.setBlockIfChunkExists((int) blockPos.x, (int) blockPos.y, (int) blockPos.z, Block.AIR);// 0 = aire

                    destroyCountDown = DESTROY_COUNTDOWN_TIME;
                }
                leftClickPressed = isLeftPressed;

                // Clic derecho = colocar bloque al lado opuesto de la cara
                boolean isRightPressed = GLFW.glfwGetMouseButton(window, GLFW.GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS;
                if (placeCountDown <= 0 && isRightPressed) {
                    int x = (int) (blockPos.x + normal.x);
                    int y = (int) (blockPos.y + normal.y);
                    int z = (int) (blockPos.z + normal.z);

                    Vector3f placement = new Vector3f(x, y, z);
                    Vector3f playerPos = camera.getPosition();

                    float playerSize = Camera.PLAYER_WIDTH; // anchura del jugador
                    float playerHeight = Camera.PLAYER_HEIGHT;

                    boolean insidePlayer = placement.x + 1 > playerPos.x - playerSize / 2f
                            && placement.x < playerPos.x + playerSize / 2f
                            && placement.y + 1 > playerPos.y
                            && placement.y < playerPos.y + playerHeight
                            && placement.z + 1 > playerPos.z - playerSize / 2f
                            && placement.z < playerPos.z + playerSize / 2f;

                    if (!insidePlayer) {
                        worldManager.setBlockIfChunkExists(x, y, z, selectedBlock);
                    }

                    placeCountDown = PLACE_COUNTDOWN_TIME;
                }
                rightClickPressed = isRightPressed;

                floatingCheckTimer += deltaTime;
                if (floatingCheckTimer < 0.5f) {
                    detectFloatingBlocksInCurrentChunk();
                    floatingCheckTimer = 0;
                }

            }

            Iterator<Vector3i> it = fallingBlocks.iterator();
            while (it.hasNext()) {
                Vector3i pos = it.next();
                Block bellow = worldManager.getBlockIfLoader(pos.x, pos.y - 1, pos.z);
                Block act = worldManager.getBlockIfLoader(pos.x, pos.y, pos.z);

                fallCountDown -= deltaTime;
                if (fallCountDown <= 0) {
                    if (bellow == AIR) {
                        worldManager.setBlock(pos.x, pos.y, pos.z, AIR);
                        worldManager.setBlock(pos.x, pos.y - 1, pos.z, act);
                        pos.y -= 1;

                    } else {
                        it.remove();
                    }
                    fallCountDown = FALL_COUNTDOWN_TIME;
                }
            }

            //Integrar chunks
            worldManager.integrateLoadedChunks();
            //UpdateChunks
            worldManager.updateChunks(camera.getPosition());
            // Renderizar chunks
            worldManager.render();

            //Bloque seleccionado en pantalla
            glMatrixMode(GL_PROJECTION);
            glPushMatrix();
            glLoadIdentity();
            glOrtho(0, width, height, 0, -1, 1); // coordenadas en píxeles
            glMatrixMode(GL_MODELVIEW);
            glPushMatrix();
            glLoadIdentity();

            textRenderer.render(20, 20); // dibuja en pantalla

            glPopMatrix();
            glMatrixMode(GL_PROJECTION);
            glPopMatrix();
            glMatrixMode(GL_MODELVIEW);

            //Cubo seleccionado imagen
            Matrix4f projection = new Matrix4f().perspective((float) Math.toRadians(45), (float) width / height, 0.1f, 100f);
            Matrix4f view = new Matrix4f()
                    .translate(0, 0, -3f); // Cámara que apunta a (0,0,0) desde Z = -3

            //cube en pantalla
            cubePreview.setRotation(new Vector3f(30f, currentTime * 50f, 0f)); // Gira suavemente

            cubePreview.render(selectedBlock.getTexture(), projection,
                    view, shaderProgram);

            //Mira central
            glDisable(GL_DEPTH_TEST);
            glBegin(GL_LINES);
            glColor3f(1, 1, 1); // blanco
            // Línea horizontal
            glVertex2f(width / 2f - 5, height / 2f);
            glVertex2f(width / 2f + 5, height / 2f);
            // Línea vertical
            glVertex2f(width / 2f, height / 2f - 5);
            glVertex2f(width / 2f, height / 2f + 5);
            glEnd();
            glEnable(GL_DEPTH_TEST);

            glfwSwapBuffers(window);

            System.out.println("IsOnGround: " + isOnGround);
        }
    }

    private void handleMouse() {
        try (MemoryStack stack = MemoryStack.stackPush()) {
            DoubleBuffer xpos = stack.mallocDouble(1);
            DoubleBuffer ypos = stack.mallocDouble(1);
            glfwGetCursorPos(window, xpos, ypos);

            double x = xpos.get(0);
            double y = ypos.get(0);

            if (firstMouse) {
                lastMouseX = x;
                lastMouseY = y;
                firstMouse = false;
            }

            float xoffset = (float) (x - lastMouseX);
            float yoffset = (float) (y - lastMouseY);

            lastMouseX = x;
            lastMouseY = y;

            camera.processMouseMovement(xoffset, yoffset, mouseSensitivity);

            if (scrollOffsetY != 0) {
                int direction = (int) Math.signum(scrollOffsetY);
                scrollOffsetY = 0; // Reiniciamos tras usarlo

                selectedBlockIndex = (selectedBlockIndex + direction + availableBlocks.length) % availableBlocks.length;
                selectedBlock = availableBlocks[selectedBlockIndex];
                System.out.println("Bloque seleccionado: " + selectedBlock.getType());
            }
        }
    }

    private void handleKeyboard(float deltaTime) {
        if (gravityDelayTime > 0) {
            gravityDelayTime -= deltaTime;
            return;
        }
        float speed = movementSpeed * deltaTime;
        Vector3f foward = new Vector3f(camera.getFront()).setComponent(1, 0).normalize();
        Vector3f right = new Vector3f(camera.getRight()).setComponent(1, 0).normalize();

        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
            move(foward, speed);
        }
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
            move(foward.negate(), speed);
        }
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
            move(right.negate(), speed);
        }
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
            move(right, speed);
        }
        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && isOnGround) {
            velocity.y = jumpForce;
            isOnGround = false;
        }
        if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) {
            move(new Vector3f(0, -1, 0), speed);
        }
    }

    private void move(Vector3f offset, float speed) {
        Vector3f proposedPos = new Vector3f(camera.getPosition()).add(offset.mul(speed));
        if (!collidesWithWorld(proposedPos)) {
            camera.setPosition(proposedPos.x, proposedPos.y, proposedPos.z);
        }
    }

    private boolean collidesWithWorld(Vector3f pos) {
        Vector3f min = new Vector3f(
                pos.x - Camera.PLAYER_WIDTH / 2f,
                pos.y,
                pos.z - Camera.PLAYER_WIDTH / 2f
        );
        Vector3f max = new Vector3f(
                pos.x + Camera.PLAYER_WIDTH / 2f,
                pos.y + Camera.PLAYER_HEIGHT,
                pos.z + Camera.PLAYER_WIDTH / 2f
        );

        // Debug
        System.out.println("Colisión check de AABB entre " + min + " y " + max);

        for (int x = (int) Math.floor(min.x); x <= Math.floor(max.x); x++) {
            for (int y = (int) Math.floor(min.y); y <= Math.floor(max.y); y++) {
                for (int z = (int) Math.floor(min.z); z <= Math.floor(max.z); z++) {
                    Block block = worldManager.getBlockIfLoader(x, y, z);
                    if (block != null && block.isSolid()) {
                        System.out.println("COLISIÓN DETECTADA en: (" + x + "," + y + "," + z + ")");
                        return true;
                    }
                }
            }
        }

        return false;
    }

    private void cleanup() {
        worldManager.cleanup();
        shaderProgram.cleanup();

        textRenderer.cleanup();

        grassT.cleanup();
        dirtT.cleanup();
        stoneT.cleanup();

        chunkLoader.terminate();
        glfwDestroyWindow(window);
        glfwTerminate();
        glfwSetErrorCallback(null).free();
    }

}

public class WorldManager {

    // Mapa para almacenar chunks con clave: "chunkX,chunkY,chunkZ"
    final Map<String, Chunk> chunks = new HashMap<>();
    private static final int LOAD_RADIUS = 3;
    private final Camera camera;
    private final ShaderProgram shader;

    //TEXTURAAAAS
    private Texture grass;
    private Texture dirt;
    private Texture stone;

    //Colas de hilos
    protected static final ConcurrentLinkedQueue<Chunk> chunksToAdd = new ConcurrentLinkedQueue<>();
    protected static final ConcurrentLinkedQueue<Chunk> chunksToMesh = new ConcurrentLinkedQueue<>();
    protected static final ConcurrentLinkedQueue<Chunk> chunksToIntegrate = new ConcurrentLinkedQueue<>();

    public static final File worldFolder = new File("world");
    private ChunkLoaderThread chunkLoader;
    private ChunkSaveThread saveThread;
    private MeshBuilderThread meshBuilder;

    public static WorldManager instance;

    public WorldManager(Camera camera, ShaderProgram shader, Texture grass, Texture dirt, Texture stone) {
        this.camera = camera;
        instance = this;
        this.shader = shader;
        this.grass = grass;
        this.dirt = dirt;
        this.stone = stone;

        if (!worldFolder.exists()) {
            worldFolder.mkdirs();
        }
        saveThread = new ChunkSaveThread(this);

    }

    public void setMeshBuilder(MeshBuilderThread meshBuilder) {
        this.meshBuilder = meshBuilder;
    }

    /**
     * Obtiene un chunk por coordenadas de chunk, si no existe lo crea y genera.
     */
    public Chunk getChunk(int chunkX, int chunkY, int chunkZ) {
        String key = key(chunkX, chunkY, chunkZ);
        Chunk chunk = chunks.get(key);
        if (chunk == null) {
            chunk = new Chunk(chunkX, chunkY, chunkZ);
            chunk.generate(); // Genera el bloque con generación simple o procedural
            chunk.buildMesh();
            chunks.put(key, chunk);
        }
        return chunk;
    }

    public Map<String, Chunk> getChunks() {
        return chunks;
    }

    public void addChunk(Chunk chunk) {
        chunks.put(chunk.getKey(), chunk);
    }

    /**
     * Devuelve el bloque en coordenadas globales (x,y,z en bloques). Retorna 0
     * (aire) si fuera de chunks cargados.
     */
    public Block getBlockIfLoader(int x, int y, int z) {
        int chunkX = Math.floorDiv(x, Chunk.SIZEx);
        int chunkY = Math.floorDiv(y, Chunk.SIZEy);
        int chunkZ = Math.floorDiv(z, Chunk.SIZEz);

        String key = chunkX + "," + chunkY + "," + chunkZ;
        Chunk chunk = chunks.get(key);

        if (chunk == null) {
            System.out.println("El Chunk(" + key + ") no encontrado");
            return null;
        }

        int localX = Math.floorMod(x, Chunk.SIZEx);
        int localY = Math.floorMod(y, Chunk.SIZEy);
        int localZ = Math.floorMod(z, Chunk.SIZEz);

        Block b = chunk.getBlock(localX, localY, localZ);
        if (b == null) {
            System.out.println("El bloque(" + x + "," + y + "," + z + ") es null");
        }
        return b;
    }

    public Chunk getChunkWithoutMesh(String key) {
        return chunks.get(key);
    }

    /**
     * Establece un bloque en coordenadas globales. Reconstruye la malla del
     * chunk modificado.
     */
    public void setBlock(int x, int y, int z, Block blockId) {
        int chunkX = Math.floorDiv(x, Chunk.SIZEx);
        int chunkY = Math.floorDiv(y, Chunk.SIZEy);
        int chunkZ = Math.floorDiv(z, Chunk.SIZEz);

        Chunk chunk = getChunk(chunkX, chunkY, chunkZ);
        if (chunk == null) {
            return;
        }

        int localX = Math.floorMod(x, Chunk.SIZEx);
        int localY = Math.floorMod(y, Chunk.SIZEy);
        int localZ = Math.floorMod(z, Chunk.SIZEz);

        chunk.setBlock(localX, localY, localZ, blockId);

        // Reemplazo dinámico de GRASS por DIRT si se coloca un bloque encima
        if (blockId != Block.AIR) {
            int belowY = y - 1;
            if (belowY >= 0) {
                Block blockBelow = getBlockIfLoader(x, belowY, z);
                if (blockBelow == GRASS) {
                    setBlock(x, belowY, z, DIRT);
                }
            }
        }

        chunk.setDirty(true);
        chunk.buildMesh();

        saveThread.requestSave(chunk);
    }

    public void setBlockIfChunkExists(int x, int y, int z, Block blockId) {
        int chunkX = Math.floorDiv(x, Chunk.SIZEx);
        int chunkY = Math.floorDiv(y, Chunk.SIZEy);
        int chunkZ = Math.floorDiv(z, Chunk.SIZEz);

        String key = key(chunkX, chunkY, chunkZ);
        if (!chunks.containsKey(key)) {
            return; // No generes un chunk nuevo
        }
        Chunk chunk = chunks.get(key);
        int localX = Math.floorMod(x, Chunk.SIZEx);
        int localY = Math.floorMod(y, Chunk.SIZEy);
        int localZ = Math.floorMod(z, Chunk.SIZEz);

        chunk.setBlock(localX, localY, localZ, blockId);

        // Reemplazo dinámico de GRASS por DIRT si se coloca un bloque encima
        if (blockId != Block.AIR) {
            int belowY = y - 1;
            if (belowY >= 0) {
                Block blockBelow = getBlockIfLoader(x, belowY, z);
                if (blockBelow == GRASS) {
                    setBlock(x, belowY, z, DIRT);
                }
            }
        }

        chunk.setDirty(true);
        chunk.buildMesh();

        saveThread.requestSave(chunk);
    }

    //si tiene soporte
    public boolean hasSupport(int x, int y, int z) {
        return getBlockIfLoader(x, y - 1, z) != AIR
                || getBlockIfLoader(x + 1, y, z) != AIR
                || getBlockIfLoader(x - 1, y, z) != AIR
                || getBlockIfLoader(x, y, z + 1) != AIR
                || getBlockIfLoader(x, y, z - 1) != AIR;
    }

    //Limitar chunks
    public void updateChunks(Vector3f playerPos) {
        int playerChunkX = Math.floorDiv((int) playerPos.x, Chunk.SIZEx);
        int playerChunkZ = Math.floorDiv((int) playerPos.z, Chunk.SIZEz);

        Set<String> stillNeeded = new HashSet<>();
        List<int[]> toLoad = new ArrayList<>();

        for (int dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
            for (int dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                int cx = playerChunkX + dx;
                int cz = playerChunkZ + dz;

                stillNeeded.add(key(cx, 0, cz));
                toLoad.add(new int[]{cx, cz});
            }
        }

        // Ordenar por distancia al jugador
        toLoad.sort(Comparator.comparingDouble(coord -> {
            float dx = playerChunkX - coord[0];
            float dz = playerChunkZ - coord[1];
            return dx * dx + dz * dz;
        }));

        // Encolar en orden de cercanía
        for (int[] coord : toLoad) {
            String k = key(coord[0], 0, coord[1]);
            if (!chunks.containsKey(k)) {
                chunkLoader.requestLoad(coord[0], coord[1]);
            }
        }

        // Descargar chunks fuera del radio
        chunks.keySet().removeIf(k -> {
            if (!stillNeeded.contains(k)) {
                saveChunk(chunks.get(k));
                chunks.get(k).cleanup();
                return true;
            }
            return false;
        });
    }

    public void saveChunk(Chunk chunk) {
        saveThread.requestSave(chunk);
    }

    public void saveChunkImmediate(Chunk chunk) throws IOException {
        String key = chunk.getKey();                  // por ejemplo: "0,0,0"
        File fileTmp = new File(worldFolder, key + ".tmp");
        File fileDat = new File(worldFolder, key + ".dat");

        // 1) Crear el .tmp y escribir sólo las capas no vacías:
        try (DataOutputStream out = new DataOutputStream(new FileOutputStream(fileTmp))) {
            // 1.1) Detectar qué capas Y tienen al menos un bloque ≠ AIR
            List<Integer> nonEmptyLayers = new ArrayList<>();
            for (int y = 0; y < Chunk.SIZEy; y++) {
                boolean hasBlock = false;
                for (int x = 0; x < Chunk.SIZEx && !hasBlock; x++) {
                    for (int z = 0; z < Chunk.SIZEz && !hasBlock; z++) {
                        if (chunk.getBlock(x, y, z) != Block.AIR) {
                            hasBlock = true;
                        }
                    }
                }
                if (hasBlock) {
                    nonEmptyLayers.add(y);
                }
            }

            // 1.2) Escribir cuántas capas no vacías vamos a guardar
            out.writeInt(nonEmptyLayers.size());

            // 1.3) Por cada capa Y, escribir primero el índice Y, y luego todos los bloques de esa capa
            for (int y : nonEmptyLayers) {
                out.writeInt(y); // índice de la capa
                for (int x = 0; x < Chunk.SIZEx; x++) {
                    for (int z = 0; z < Chunk.SIZEz; z++) {
                        Block b = chunk.getBlock(x, y, z);
                        out.writeInt(Block.getBlockId(b));
                    }
                }
            }

            // El try-with-resources se encarga de cerrar 'out' aquí al salir del bloque
        }

        // 2) Una vez fuera del try, el flujo ya está cerrado. Ahora podemos renombrar.
        //    Primero borramos el .dat viejo (si existe)
        if (fileDat.exists()) {
            if (!fileDat.delete()) {
                System.err.println("No se pudo borrar el archivo antiguo: " + fileDat.getPath());
                // Si quieres, puedes abortar aquí o programar un retry.
            }
        }

        // 3) Finalmente renombrar .tmp → .dat
        if (!fileTmp.renameTo(fileDat)) {
            System.err.println("No se pudo renombrar " + fileTmp.getName() + " a " + fileDat.getName());
            // Opcional: podrías volver a intentar más tarde, o moverlo a otra carpeta “retry/”
        }
    }

    public boolean loadChunk(Chunk chunk) {

        String filename = chunk.getKey() + ".dat";
        File file = new File(worldFolder, filename);
        File tmp = new File(worldFolder, chunk.getKey() + ".tmp");
        if (!file.exists() || tmp.exists()) {
            return false;
        }
        try (DataInputStream in = new DataInputStream(new FileInputStream(file))) {

            //Reinicio para evitar errores de caida
            // Comprobación del chunk del jugador
            int playerChunkX = Math.floorDiv((int) camera.getPosition().x, Chunk.SIZEx);
            int playerChunkZ = Math.floorDiv((int) camera.getPosition().z, Chunk.SIZEz);

            if (chunk.chunkX == playerChunkX && chunk.chunkZ == playerChunkZ) {
                Game.gravityDelayTime = Game.GRAVITY_COUNTDOWN_TIME;
            }

            //Game.gravityDelayTime = Game.GRAVITY_COUNTDOWN_TIME;
            // Inicializar todo con AIR primero para evitar nulos
            for (int x = 0; x < Chunk.SIZEx; x++) {
                for (int y = terrainHeight; y < Chunk.SIZEy; y++) {
                    for (int z = 0; z < Chunk.SIZEz; z++) {
                        chunk.setBlock(x, y, z, Block.AIR);
                    }
                }
            }

            int layerCount = in.readInt(); // cuántas capas hay

            for (int i = 0; i < layerCount; i++) {
                int y = in.readInt(); // índice de la capa

                for (int x = 0; x < Chunk.SIZEx; x++) {
                    for (int z = 0; z < Chunk.SIZEz; z++) {
                        int id = in.readInt();
                        Block b = Block.getBlockById(id);
                        chunk.setBlock(x, y, z, b);
                    }
                }
            }
            return true;

        } catch (IOException e) {
            System.err.println(" Error leyendo chunk " + chunk.getKey() + ": " + e.getMessage());
            return false;
        }
    }

    private Block getBlockById(int id) {
        if (id >= 0 && id < Block.BLOCKS.length) {
            return Block.BLOCKS[id];
        } else if (id == 0) {
            return Block.AIR;
        }

        return null;
    }

    public Chunk pollChunkToMesh() {
        return chunksToMesh.poll();
    }

    public void loadOrGenerateChunk(int chunkX, int chunkZ) {
        String key = key(chunkX, 0, chunkZ);

        // Si ya está cargado en memoria, no hacemos nada.
        if (chunks.containsKey(key)) {
            return;
        }

        // Si ya se pidió su carga (o está en proceso), tampoco hacemos nada.
        if (chunkLoader.hasPendingRequest(chunkX, chunkZ)) {
            return;
        }

        //Reinicio para evitar errores de caida
        // Comprobación del chunk del jugador
        int playerChunkX = Math.floorDiv((int) camera.getPosition().x, Chunk.SIZEx);
        int playerChunkZ = Math.floorDiv((int) camera.getPosition().z, Chunk.SIZEz);

        if (chunkX == playerChunkX && chunkZ == playerChunkZ) {
            Game.gravityDelayTime = Game.GRAVITY_COUNTDOWN_TIME;
        }

        // Si no, pedimos al hilo de carga que lo maneje
        chunkLoader.requestLoad(chunkX, chunkZ);

    }

    public void integrateLoadedChunks() {
        synchronized (chunksToAdd) {
            for (Chunk chunk : chunksToAdd) {
                //if (chunk == null) {
                //    continue;
                //}

                //Reinicio para evitar errores de caida
                // Comprobación del chunk del jugador
                int playerChunkX = Math.floorDiv((int) camera.getPosition().x, Chunk.SIZEx);
                int playerChunkZ = Math.floorDiv((int) camera.getPosition().z, Chunk.SIZEz);

                if (chunk.chunkX == playerChunkX && chunk.chunkZ == playerChunkZ) {
                    Game.gravityDelayTime = Game.GRAVITY_COUNTDOWN_TIME;
                }

                chunk.buildMesh(); // ahora sí con GL activo
                chunks.put(chunk.getKey(), chunk);
            }
            chunksToAdd.clear();
        }
    }

    public void setChunkLoader(ChunkLoaderThread loader) {
        this.chunkLoader = loader;
    }

    public void enqueueChunkToAdd(Chunk c) {
        synchronized (chunksToAdd) {
            chunksToAdd.add(c);
        }
    }

    public void enqueueChunkToMesh(Chunk c) {
        chunksToMesh.add(c);
    }

    public void enqueueChunkToIntegrate(Chunk c) {
        chunksToIntegrate.add(c);
    }

    /**
     * Renderiza todos los chunks cargados
     */
    public void render() {
        // 1) Calcula proyección y vista (o mantenlas en campos si no cambian cada frame)
        Matrix4f projection = camera.getProjectionMatrix(70, 1280f / 720f, 0.01f, 100f);
        Matrix4f view = camera.getViewMatrix();

        // 2) Bindea TU shader antes de setear uniforms
        shader.bind();
        // Ahora sí, OpenGL sabe que “viewPos” y “lightPos” van a este shader
        shader.setUniform3f("viewPos", camera.getEyePosition());
        shader.setUniform3f("lightDir", new Vector3f(-0.5f, -1.0f, -0.5f).normalize());
        shader.setUniformMat4("view", view);
        shader.setUniformMat4("projection", projection);
        // (También podrías setear aquí las matrices view/projection si no lo haces dentro de Chunk.render)

        // 3) Dibuja todos los chunks
        for (Chunk chunk : chunks.values()) {
            // Chunk.render seguirá bind() y unbind() internamente
            // pero como tú ya bindiaste el shader aquí, al menos los uniforms ya existen
            chunk.render(projection, view, shader, grass, dirt, stone);
        }

        // 4) Desbindea el shader cuando termines
        shader.unbind();
    }

    private String key(int x, int y, int z) {
        return x + "," + y + "," + z;
    }

    /**
     * Limpia todos los recursos de chunks
     */
    public void cleanup() {
        for (Chunk chunk : chunks.values()) {
            chunk.cleanup();
        }
        chunks.clear();
    }

    public void startThreads() {
        meshBuilder.start();
        saveThread.start();
    }

}

public class Chunk {

    // … campos existentes …
    private Mesh grassMesh;
    private Mesh dirtMesh;
    private Mesh stoneMesh;

    public static final int SIZEx = 16;
    public static final int SIZEy = 16;
    public static final int SIZEz = 16;

    public static final int terrainHeight = 4;

    private boolean dirty = false;

    public final int chunkX, chunkY, chunkZ;
    private final Block[][][] blocks = new Block[SIZEx][SIZEy][SIZEz];

    public Chunk(int chunkX, int chunkY, int chunkZ) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.chunkZ = chunkZ;
    }

    /**
     * Generación simple de bloques, por ahora piso sólido hasta y = 4
     */
    public void generate() {
        for (int x = 0; x < SIZEx; x++) {
            for (int y = 0; y < SIZEy; y++) {
                for (int z = 0; z < SIZEz; z++) {
                    if (y == terrainHeight) {
                        blocks[x][y][z] = Block.GRASS;
                    } else if (y < terrainHeight && y > 0) {
                        blocks[x][y][z] = DIRT;
                    } else if (y == 0) {
                        blocks[x][y][z] = STONE;
                    } else {
                        blocks[x][y][z] = AIR;
                    }
                }
            }
        }

        System.out.println("Generando chunk " + getKey());

        // Verificación segura: mostrar un bloque válido dentro del rango
        int testX = Math.min(4, SIZEx - 1);
        int testY = Math.min(4, SIZEy - 1);
        int testZ = Math.min(4, SIZEz - 1);

        Block testBlock = blocks[testX][testY][testZ];
        if (testBlock != null) {
            System.out.println("Bloque (" + testX + "," + testY + "," + testZ + ") = " + testBlock.getType());
        } else {
            System.out.println("Bloque (" + testX + "," + testY + "," + testZ + ") = null ⚠️");
        }
    }

    //Si el cubo esta de cara al cielo
    public boolean isExposedToSky(int x, int y, int z) {
        for (int ty = y + 1; ty < SIZEy; ty++) {
            if (blocks[x][ty][z] != null && blocks[x][ty][z].isSolid()) {
                return false; // hay un bloque encima
            }
        }
        return true;
    }

    /**
     * Establece un bloque dentro del chunk local
     */
    public void setBlock(int x, int y, int z, Block blockId) {
        if (blockId == null) {
            System.err.println("ERROR! se intentra colocar un bloque null en (" + x + "," + y + "," + z + ")");
            return;
        }

        if (x >= 0 && x < SIZEx && y >= 0 && y < SIZEy && z >= 0 && z < SIZEz) {
            blocks[x][y][z] = blockId;
            dirty = true;
            System.out.println("Bloque sobrescrito en" + x + "," + y + "," + z + "con " + blockId.getType());
        }

    }

    public boolean isDirty() {
        return dirty;
    }

    public void setDirty(boolean flag) {
        this.dirty = flag;
    }

    /**
     * Obtiene el bloque en coordenadas locales del chunk
     */
    public Block getBlock(int x, int y, int z) {
        if (x < 0 || x >= SIZEx || y < 0 || y >= SIZEy || z < 0 || z >= SIZEz) {
            return AIR;
        }
        if (blocks[x][y][z] == null) {
            return AIR;
        }
        if (x >= 0 && x < SIZEx && y >= 0 && y < SIZEy && z >= 0 && z < SIZEz) {
            return blocks[x][y][z];
        }
        return AIR;
    }

    /**
     * Construye o reconstruye la malla del chunk aplicando ocultación de caras
     */
    public void buildMesh() {
        // 1) Tres listas de floats para GRASS, DIRT y STONE:
        List<Float> grassVerts = new ArrayList<>();
        List<Float> dirtVerts = new ArrayList<>();
        List<Float> stoneVerts = new ArrayList<>();

        for (int x = 0; x < SIZEx; x++) {
            for (int y = 0; y < SIZEy; y++) {
                for (int z = 0; z < SIZEz; z++) {
                    Block block = blocks[x][y][z];
                    if (block != null && block.isSolid()) {
                        float[] cube = CubeGenerator.createCube(x, y, z, blocks);

                        // ¿De qué tipo es este bloque?
                        switch (block.getType()) {
                            case GRASS:
                                for (float f : cube) {
                                    grassVerts.add(f);
                                }
                                break;
                            case DIRT:
                                for (float f : cube) {
                                    dirtVerts.add(f);
                                }
                                break;
                            case STONE:
                                for (float f : cube) {
                                    stoneVerts.add(f);
                                }
                                break;
                            default:
                            // (si añades más tipos, agrégalos aquí)
                            }
                    }
                }
            }
        }

        // 2) Convertir las tres listas a tres arrays float[]
        if (!grassVerts.isEmpty()) {
            float[] gArr = new float[grassVerts.size()];
            for (int i = 0; i < gArr.length; i++) {
                gArr[i] = grassVerts.get(i);
            }
            if (grassMesh != null) {
                grassMesh.cleanup();
            }
            grassMesh = new Mesh(gArr);
        } else {
            grassMesh = null;
        }

        if (!dirtVerts.isEmpty()) {
            float[] dArr = new float[dirtVerts.size()];
            for (int i = 0; i < dArr.length; i++) {
                dArr[i] = dirtVerts.get(i);
            }
            if (dirtMesh != null) {
                dirtMesh.cleanup();
            }
            dirtMesh = new Mesh(dArr);
        } else {
            dirtMesh = null;
        }

        if (!stoneVerts.isEmpty()) {
            float[] sArr = new float[stoneVerts.size()];
            for (int i = 0; i < sArr.length; i++) {
                sArr[i] = stoneVerts.get(i);
            }
            if (stoneMesh != null) {
                stoneMesh.cleanup();
            }
            stoneMesh = new Mesh(sArr);
        } else {
            stoneMesh = null;
        }

        // 3) Limpiar la “antigua” malla completa (si la tenías)
        // (opcional, en tu caso ya no usas 'this.mesh' sino las tres nuevas)
    }

    /**
     * Verifica si un bloque vecino es aire o está fuera del chunk
     */
    public boolean isTransparent(int x, int y, int z) {
        if (x < 0 || x >= SIZEx || y < 0 || y >= SIZEy || z < 0 || z >= SIZEz) {
            return true; // Borde del chunk
        }
        return blocks[x][y][z] == Block.AIR;
    }

    public String getKey() {
        return chunkX + ",0," + chunkZ;
    }

    public void render(Matrix4f projection, Matrix4f view, ShaderProgram shader,
            Texture grassTex,
            Texture dirtTex,
            Texture stoneTex) {
        // PROYECCIÓN y VISTA ya las pasaste desde WorldManager

        Matrix4f model = new Matrix4f().translate(
                chunkX * SIZEx,
                chunkY * SIZEy,
                chunkZ * SIZEz
        );

        Matrix4f mvp = new Matrix4f(projection).mul(view).mul(model);

        // 1) Dibuja GRASS
        if (grassMesh != null) {
            shader.bind();
            shader.setUniformMat4("model", model);
            shader.setUniformMat4("mvp", mvp);
            glActiveTexture(GL_TEXTURE0);
            grassTex.bind();
            shader.setUniform1i("textureSampler", 0);
            grassMesh.render();
            shader.unbind();
        }

        // 2) Dibuja DIRT
        if (dirtMesh != null) {
            shader.bind();
            shader.setUniformMat4("model", model);
            shader.setUniformMat4("mvp", mvp);
            glActiveTexture(GL_TEXTURE0);
            dirtTex.bind();
            shader.setUniform1i("textureSampler", 0);
            dirtMesh.render();
            shader.unbind();
        }
        // 3) Dibuja STONE
        if (stoneMesh != null) {
            shader.bind();
            shader.setUniformMat4("model", model);
            shader.setUniformMat4("mvp", mvp);
            glActiveTexture(GL_TEXTURE0);
            stoneTex.bind();
            shader.setUniform1i("textureSampler", 0);
            stoneMesh.render();
            shader.unbind();
        }
    }

    public Mesh getMeshGrass() {
        return grassMesh;
    }

    public Mesh getMeshDirt() {
        return dirtMesh;
    }

    public Mesh getMeshStone() {
        return stoneMesh;
    }

    public Mesh getMeshByBlockType(BlockType type) {
        if (type == BlockType.DIRT) {
            return dirtMesh;
        }
        if (type == BlockType.GRASS) {
            return grassMesh;
        }
        if (type == BlockType.STONE) {
            return stoneMesh;
        }
        return null;
    }

    public void cleanup() {
        if (grassMesh != null) {
            grassMesh.cleanup();
        }
        if (dirtMesh != null) {
            dirtMesh.cleanup();
        }
        if (stoneMesh != null) {
            stoneMesh.cleanup();
        }
    }
}

public class CubeGenerator {

    // Tamaño de cada celda de la textura (col: 3 columnas, row: 2 filas)
    private static final float UV_WIDTH = 1.0f / 3.0f;
    private static final float UV_HEIGHT = 1.0f / 2.0f;

    public static float[] createCube(int x, int y, int z, Block[][][] blocks) {
        List<Float> data = new ArrayList<>();

        for (Direction dir : Direction.values()) {
            int nx = x + dir.offsetX;
            int ny = y + dir.offsetY;
            int nz = z + dir.offsetZ;

            if (isAir(blocks, nx, ny, nz)) {
                // Elegimos coordenadas de textura según la cara
                int texCol = getTexCol(dir);
                int texRow = getTexRow(dir);
                boolean isShadow = isInShadow(nx, ny, nz, dir);
                float shade = isShadow ? 0.5f : 1.0f;
                addFace(data, x, y, z, dir, texCol, texRow, blocks, shade);
            }
        }

        float[] result = new float[data.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = data.get(i);
        }
        return result;
    }

    private static boolean isAir(Block[][][] blocks, int x, int y, int z) {
        if (x < 0 || x >= blocks.length || y < 0 || y >= blocks[0].length || z < 0 || z >= blocks[0][0].length) {
            return true; // Consideramos aire fuera de los límites
        }
        if (blocks[x][y][z].isSolid && blocks[x][y][z] != null) {
            return false;
        }
        return true;
    }

    public enum Direction {
        UP(0, 1, 0), DOWN(0, -1, 0),
        FRONT(0, 0, 1), BACK(0, 0, -1),
        LEFT(-1, 0, 0), RIGHT(1, 0, 0);

        public final int offsetX, offsetY, offsetZ;

        Direction(int x, int y, int z) {
            this.offsetX = x;
            this.offsetY = y;
            this.offsetZ = z;
        }
    }

    private static int getTexCol(Direction dir) {
        switch (dir) {
            case UP:
                return 0;
            case DOWN:
                return 2;
            case FRONT:
                return 1;
            case BACK:
                return 1;
            case LEFT:
                return 0;
            case RIGHT:
                return 2;
        }
        return 0;
    }

    private static int getTexRow(Direction dir) {
        switch (dir) {
            case UP:
                return 0;
            case DOWN:
                return 0;
            case FRONT:
                return 0;
            case BACK:
                return 1;
            case LEFT:
                return 1;
            case RIGHT:
                return 1;
        }
        return 0;
    }

    private static void addFace(List<Float> data, int x, int y, int z, Direction dir, int texCol, int texRow, Block[][][] blocks, Float lightLevel) {
        float[][] positions = CubeFace.getFaceVertices(dir);
        float[] normal = CubeFace.getNormal(dir);

        float u0 = texCol * UV_WIDTH;
        float v0 = texRow * UV_HEIGHT;
        float u1 = u0 + UV_WIDTH;
        float v1 = v0 + UV_HEIGHT;

        // UVs: se asignan en sentido horario desde esquina inferior izquierda
        float[][] uvs = new float[][]{
            {u0, v1},
            {u1, v1},
            {u1, v0},
            {u0, v0}
        };

        // calculo del ao
        float[] aoValues = new float[4];
        for (int i = 0; i < 4; i++) {
            // posLocal = posiciones del vértice en [0..1] relativo al cubo
            int localX = (int) positions[i][0];
            int localY = (int) positions[i][1];
            int localZ = (int) positions[i][2];

            aoValues[i] = computeAOForCorner(x, y, z, dir, localX, localY, localZ, blocks);
           }

        // Triángulo 1 (v0, v1, v2)
        addVertex(data, positions[0], uvs[0], normal, x, y, z, lightLevel, aoValues[0]);
        addVertex(data, positions[1], uvs[1], normal, x, y, z, lightLevel, aoValues[1]);
        addVertex(data, positions[2], uvs[2], normal, x, y, z, lightLevel, aoValues[2]);
        // Triángulo 2 (v2, v3, v0)
        addVertex(data, positions[2], uvs[2], normal, x, y, z, lightLevel, aoValues[2]);
        addVertex(data, positions[3], uvs[3], normal, x, y, z, lightLevel, aoValues[3]);
        addVertex(data, positions[0], uvs[0], normal, x, y, z, lightLevel, aoValues[0]);
    }

    private static float computeAOForCorner(
            int x, int y, int z,
            Direction dir,
            int localX, int localY, int localZ,
            Block[][][] blocks) {

        boolean side1 = false, side2 = false, corner = false;
        int bx, by, bz;

        switch (dir) {
            // ------- CARA SUPERIOR -------
            case UP:
                // Nivel base para la cara UP es y+1, pero vecinos para AO miramos a y:
                int worldX_up = x + localX;
                int worldY_up = y+1;       // ¡Ojo! usamos y, no y+1
                int worldZ_up = z + localZ;

                // side1: vecino en X positivo o negativo (misma Y)
                bx = worldX_up + ((localX == 0) ? -1 : +1);
                by = worldY_up;
                bz = worldZ_up;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }

                // side2: vecino en Z positivo o negativo (misma Y)
                bx = worldX_up;
                by = worldY_up;
                bz = worldZ_up + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }

                // corner: el vecino en la esquina diagonal (misma Y)
                bx = worldX_up + ((localX == 0) ? -1 : +1);
                by = worldY_up;
                bz = worldZ_up + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;

            // ------- CARA INFERIOR -------
            case DOWN:
                // Para DOWN la cara está en y-1, pero vecinos siguen en y
                int worldX_down = x + localX;
                int worldY_down = y-1;  // OJO: nivel “y” (cara inferior apunta hacia abajo, pero AO se mira en y)
                int worldZ_down = z + localZ;

                // side1 en X
                bx = worldX_down + ((localX == 0) ? -1 : +1);
                by = worldY_down;
                bz = worldZ_down;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }
                // side2 en Z
                bx = worldX_down;
                by = worldY_down;
                bz = worldZ_down + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }
                // corner en diagonal (misma Y)
                bx = worldX_down + ((localX == 0) ? -1 : +1);
                by = worldY_down;
                bz = worldZ_down + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;

            // ------- CARA FRONTAL -------
            case FRONT:
                // Cara FRONT en z+1, pero vecinos para AO en z:
                int worldX_front = x + localX;
                int worldY_front = y + localY; // en FRONTAL hay variación en Y
                int worldZ_front = z+1;

                // side1: x ±1, misma Z
                bx = worldX_front + ((localX == 0) ? -1 : +1);
                by = worldY_front;
                bz = worldZ_front;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }
                // side2: y ±1, misma Z
                bx = worldX_front;
                by = worldY_front + ((localY == 0) ? -1 : +1);
                bz = worldZ_front;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }
                // corner: diagonal en X e Y, misma Z
                bx = worldX_front + ((localX == 0) ? -1 : +1);
                by = worldY_front + ((localY == 0) ? -1 : +1);
                bz = worldZ_front;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;

            // ------- CARA TRASERA -------
            case BACK:
                // Cara BACK en z-1, pero vecinos en z:
                int worldX_back = x + localX;
                int worldY_back = y + localY;
                int worldZ_back = z-1;

                // side1: x ±1, misma Z
                bx = worldX_back + ((localX == 0) ? -1 : +1);
                by = worldY_back;
                bz = worldZ_back;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }
                // side2: y ±1, misma Z
                bx = worldX_back;
                by = worldY_back + ((localY == 0) ? -1 : +1);
                bz = worldZ_back;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }
                // corner: diagonal en X e Y, misma Z
                bx = worldX_back + ((localX == 0) ? -1 : +1);
                by = worldY_back + ((localY == 0) ? -1 : +1);
                bz = worldZ_back;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;

            // ------- CARA IZQUIERDA -------
            case LEFT:
                // Cara LEFT en x-1, vecinos en x:
                int worldX_left = x-1;
                int worldY_left = y + localY;
                int worldZ_left = z + localZ;

                // side1: z ±1, mismo X
                bx = worldX_left;
                by = worldY_left;
                bz = worldZ_left + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }
                // side2: y ±1, mismo X
                bx = worldX_left;
                by = worldY_left + ((localY == 0) ? -1 : +1);
                bz = worldZ_left;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }
                // corner: diagonal en Y y Z, mismo X
                bx = worldX_left;
                by = worldY_left + ((localY == 0) ? -1 : +1);
                bz = worldZ_left + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;

            // ------- CARA DERECHA -------
            case RIGHT:
                // Cara RIGHT en x+1, vecinos en x:
                int worldX_right = x+1;
                int worldY_right = y + localY;
                int worldZ_right = z + localZ;

                // side1: z ±1, mismo X
                bx = worldX_right;
                by = worldY_right;
                bz = worldZ_right + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side1 = true;
                }
                // side2: y ±1, mismo X
                bx = worldX_right;
                by = worldY_right + ((localY == 0) ? -1 : +1);
                bz = worldZ_right;
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    side2 = true;
                }
                // corner: diagonal en Y y Z, mismo X
                bx = worldX_right;
                by = worldY_right + ((localY == 0) ? -1 : +1);
                bz = worldZ_right + ((localZ == 0) ? -1 : +1);
                if (inBounds(bx, by, bz, blocks) && blocks[bx][by][bz].isSolid()) {
                    corner = true;
                }
                break;
        }

        // Ahora calculamos el valor final de AO, entre 0.0 (muy oscuro) y 1.0 (sin oclusión).
        float ao;
        if (side1 && side2) {
            // Si ambos lados laterales están ocupados → esquina completamente cerrada
            ao = 0.0f;
        } else {
            // La fórmula es aproximada: 
            // → cada “lado ocupado” reduce 0.5
            // → la esquina diagonal reduce 0.2
            float occ = 0.0f;
            if (side1) {
                occ += 0.5f;
            }
            if (side2) {
                occ += 0.5f;
            }
            if (corner) {
                occ += 0.2f;
            }
            ao = 1.0f - occ;
            // Clamp a [0,1]
            if (ao < 0f) {
                ao = 0f;
            }
            if (ao > 1f) {
                ao = 1f;
            }
        }

        return ao;
    }

    /**
     * inBounds: verifica que (bx,by,bz) esté dentro de los límites del chunk
     * (blocks.length = SIZEx, blocks[0].length = SIZEy, blocks[0][0].length =
     * SIZEz).
     */
    private static boolean inBounds(int bx, int by, int bz, Block[][][] blocks) {
        return bx >= 0 && bx < blocks.length
                && by >= 0 && by < blocks[0].length
                && bz >= 0 && bz < blocks[0][0].length;
    }

    /**
     * Recorrer a partir de (x,y,z) en dirección 'dir', tantas celdas como sea
     * necesario hasta encontrar un bloque sólido. Si encuentra un bloque sólido
     * antes de quedarse sin mundo, devuelve true (hay sombra). En caso
     * contrario, devuelve false (no hay nada que proyecte sombra).
     */
    private static boolean isInShadow(int x, int y, int z, Direction dir) {
        // Partimos desde el primer vecino inmediato
        int cx = x + dir.offsetX;
        int cy = y + dir.offsetY;
        int cz = z + dir.offsetZ;

        // Mientras queden coordenadas “válidas” (getBlockIfLoader != null),
        // avanzamos en la misma dirección.
        while (true) {
            Block b = WorldManager.instance.getBlockIfLoader(cx, cy, cz);
            if (b == null) {
                // Nos salimos de los chunks cargados → asumimos que no hay sombra
                return false;
            }
            if (b != Block.AIR && b.isSolid()) {
                // Encontramos un bloque sólido → proyecta sombra
                return true;
            }
            // Si es aire, seguimos un paso más
            cx += dir.offsetX;
            cy += dir.offsetY;
            cz += dir.offsetZ;
        }
    }

    public static float[] createFace(float x, float y, float z, Direction dir, boolean inShadow) {
        // Vertices (posX, posY, posZ, u, v, normX, normY, normZ)
        switch (dir) {
            case FRONT:
                return new float[]{
                    x, y, z + 1, 0, 0, 0, 0, 1,
                    x + 1, y, z + 1, 1, 0, 0, 0, 1,
                    x + 1, y + 1, z + 1, 1, 1, 0, 0, 1,
                    x + 1, y + 1, z + 1, 1, 1, 0, 0, 1,
                    x, y + 1, z + 1, 0, 1, 0, 0, 1,
                    x, y, z + 1, 0, 0, 0, 0, 1
                };

            case BACK:
                return new float[]{
                    x + 1, y, z, 0, 0, 0, 0, -1,
                    x, y, z, 1, 0, 0, 0, -1,
                    x, y + 1, z, 1, 1, 0, 0, -1,
                    x, y + 1, z, 1, 1, 0, 0, -1,
                    x + 1, y + 1, z, 0, 1, 0, 0, -1,
                    x + 1, y, z, 0, 0, 0, 0, -1
                };

            case LEFT:
                return new float[]{
                    x, y, z, 0, 0, -1, 0, 0,
                    x, y, z + 1, 1, 0, -1, 0, 0,
                    x, y + 1, z + 1, 1, 1, -1, 0, 0,
                    x, y + 1, z + 1, 1, 1, -1, 0, 0,
                    x, y + 1, z, 0, 1, -1, 0, 0,
                    x, y, z, 0, 0, -1, 0, 0
                };

            case RIGHT:
                return new float[]{
                    x + 1, y, z + 1, 0, 0, 1, 0, 0,
                    x + 1, y, z, 1, 0, 1, 0, 0,
                    x + 1, y + 1, z, 1, 1, 1, 0, 0,
                    x + 1, y + 1, z, 1, 1, 1, 0, 0,
                    x + 1, y + 1, z + 1, 0, 1, 1, 0, 0,
                    x + 1, y, z + 1, 0, 0, 1, 0, 0
                };

            case UP:
                return new float[]{
                    x, y + 1, z + 1, 0, 0, 0, 1, 0,
                    x + 1, y + 1, z + 1, 1, 0, 0, 1, 0,
                    x + 1, y + 1, z, 1, 1, 0, 1, 0,
                    x + 1, y + 1, z, 1, 1, 0, 1, 0,
                    x, y + 1, z, 0, 1, 0, 1, 0,
                    x, y + 1, z + 1, 0, 0, 0, 1, 0
                };

            case DOWN:
                return new float[]{
                    x, y, z, 0, 0, 0, -1, 0,
                    x + 1, y, z, 1, 0, 0, -1, 0,
                    x + 1, y, z + 1, 1, 1, 0, -1, 0,
                    x + 1, y, z + 1, 1, 1, 0, -1, 0,
                    x, y, z + 1, 0, 1, 0, -1, 0,
                    x, y, z, 0, 0, 0, -1, 0
                };
        }

        return new float[0]; // Fallback
    }

    private static void addVertex(List<Float> data, float[] pos, float[] uv, float[] normal, int x, int y, int z, Float shade, float ao) {
        data.add(pos[0] + x);
        data.add(pos[1] + y);
        data.add(pos[2] + z);

        data.add(normal[0]);
        data.add(normal[1]);
        data.add(normal[2]);

        data.add(uv[0]);
        data.add(uv[1]);

        data.add(shade);

        data.add(ao);

    }
}

//Fragment shader:

#version 330 core

in vec2 fragTexCoord;
in vec3 fragPos;
in vec3 normal;
in float shadeFactor;
in float vertAO;

out vec4 fragColor;

uniform sampler2D textureSampler;


// Dirección de la luz (normalizada), ej: vec3(-0.5, -1.0, -0.5)
uniform vec3 lightDir;

void main() {
    vec3 norm = normalize(normal);
    
    // Dirección opuesta a la luz (porque viene "desde el sol")
    float diff = max(dot(norm, -lightDir), 0.0);
    
    diff*=shadeFactor*vertAO;
    //float ambient = max(0.3,shadeFactor*vertAO);
    vec3 ambient = vec3(0.3)*shadeFactor*vertAO; // Luz ambiental constante
    vec3 diffuse = vec3(0.7) * diff;

    vec3 texColor = texture(textureSampler, fragTexCoord).rgb;

    vec3 shadeDiffuse = diffuse*shadeFactor;

    vec3 lighting = (ambient + shadeDiffuse)*texColor;

    fragColor = vec4(lighting, 1.0);
}

//Vertex Shader:
#version 330 core

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec2 inTexCoord;
layout(location = 3) in float inShade;
layout(location = 4) in float inAO;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec2 fragTexCoord;
out vec3 fragPos;
out vec3 normal;
out float shadeFactor;
out float vertAO;

void main() {
    fragTexCoord = inTexCoord;
    vec4 worldPos = model * vec4(inPosition, 1.0);
    fragPos = worldPos.xyz;
    normal = mat3(transpose(inverse(model))) * inNormal;
    shadeFactor = inShade;
    vertAO = inAO;

    gl_Position = projection * view * worldPos;
}

public class Camera {

    private Vector3f position;
    private float pitch; // Rotación vertical
    private float yaw;   // Rotación horizontal
    private final Vector3f front;
    private final Vector3f up;
    private final Vector3f right;
    private final Vector3f worldUp;

    public static final float PLAYER_WIDTH = 0.5f;
    public static final float PLAYER_HEIGHT = 1.8f;

    public Camera() {
        position = new Vector3f();
        pitch = 0.0f;
        yaw = -90.0f; // mirando hacia adelante (eje -Z)
        front = new Vector3f(0, 0, -1);
        up = new Vector3f(0, 1, 0);
        right = new Vector3f(1, 0, 0);
        worldUp = new Vector3f(0, 1, 0);
        updateCameraVectors();
    }

    public Matrix4f getViewMatrix() {
        Vector3f eye = new Vector3f(position).add(0,1.6f,0); //posicion cabeza
        return new Matrix4f().lookAt(eye, new Vector3f(eye).add(front),new Vector3f(0,1,0));
    }

    public Matrix4f getProjectionMatrix(float fov, float aspect, float near, float far) {
        return new Matrix4f().perspective((float) Math.toRadians(fov), aspect, near, far);
    }

    public void processKeyboard(Vector3f direction, float speed) {
        Vector3f velocity = new Vector3f(direction).mul(speed);
        position.add(velocity);
    }

    public void processMouseMovement(float xoffset, float yoffset, float sensitivity) {
        yaw += xoffset * sensitivity;
        pitch -= yoffset * sensitivity;

        // Limitar la inclinación vertical
        if (pitch > 89.0f) {
            pitch = 89.0f;
        }
        if (pitch < -89.0f) {
            pitch = -89.0f;
        }

        updateCameraVectors();
    }

    private void updateCameraVectors() {
        // Calcula la dirección del frente con yaw/pitch
        front.x = (float) Math.cos(Math.toRadians(yaw)) * (float) Math.cos(Math.toRadians(pitch));
        front.y = (float) Math.sin(Math.toRadians(pitch));
        front.z = (float) Math.sin(Math.toRadians(yaw)) * (float) Math.cos(Math.toRadians(pitch));
        front.normalize();

        right.set(front).cross(worldUp).normalize();
        up.set(right).cross(front).normalize();
    }

    public Vector3f getPosition() {
        return position;
    }

    public Vector3f getFront() {
        return front;
    }

    public Vector3f getRight() {
        return right;
    }

    public Vector3f getUp() {
        return up;
    }

    public void moveForward(float speed) {
        position.add(new Vector3f(front).mul(speed));
    }

    public void moveBackward(float speed) {
        position.sub(new Vector3f(front).mul(speed));
    }

    public void moveLeft(float speed) {
        position.sub(new Vector3f(right).mul(speed));
    }

    public void moveRight(float speed) {
        position.add(new Vector3f(right).mul(speed));
    }

    public void moveUp(float speed) {
        position.add(new Vector3f(worldUp).mul(speed));
    }

    public void moveDown(float speed) {
        position.sub(new Vector3f(worldUp).mul(speed));
    }

    public Vector3f getBoundingBoxMin() {
        return new Vector3f(
                position.x - PLAYER_WIDTH / 2f,
                position.y,
                position.z - PLAYER_WIDTH / 2f
        );
    }

    public Vector3f getBoundingBoxMax() {
        return new Vector3f(
                position.x + PLAYER_WIDTH / 2f,
                position.y + PLAYER_HEIGHT,
                position.z + PLAYER_WIDTH / 2f
        );
    }
    
    public void setPosition(float x, float y, float z){
        position = new Vector3f(x, y, z);
    }
    
    public Vector3f getEyePosition(){
        return new Vector3f(position).add(0,1.6f,0);
    }
}